Programuji v ruby on rails a m√°m tyto migrace, modely a kontrolery:


class CreateRodauth < ActiveRecord::Migration[7.1]
  def change
    create_table :accounts do |t|
      t.integer :status, null: false, default: 1
      t.string :email, null: false
      t.index :email, unique: true, where: "status IN (1, 2)"
      t.string :password_hash
    end

    # Used by the password reset feature
    create_table :account_password_reset_keys, id: false do |t|
      t.integer :id, primary_key: true
      t.foreign_key :accounts, column: :id
      t.string :key, null: false
      t.datetime :deadline, null: false
      t.datetime :email_last_sent, null: false, default: -> { "CURRENT_TIMESTAMP" }
    end

    # Used by the account verification feature
    create_table :account_verification_keys, id: false do |t|
      t.integer :id, primary_key: true
      t.foreign_key :accounts, column: :id
      t.string :key, null: false
      t.datetime :requested_at, null: false, default: -> { "CURRENT_TIMESTAMP" }
      t.datetime :email_last_sent, null: false, default: -> { "CURRENT_TIMESTAMP" }
    end

    # Used by the verify login change feature
    create_table :account_login_change_keys, id: false do |t|
      t.integer :id, primary_key: true
      t.foreign_key :accounts, column: :id
      t.string :key, null: false
      t.string :login, null: false
      t.datetime :deadline, null: false
    end

    # Used by the remember me feature
    create_table :account_remember_keys, id: false do |t|
      t.integer :id, primary_key: true
      t.foreign_key :accounts, column: :id
      t.string :key, null: false
      t.datetime :deadline, null: false
    end
  end
end

# This migration comes from active_storage (originally 20170806125915)
class CreateActiveStorageTables < ActiveRecord::Migration[7.0]
  def change
    # Use Active Record's configured type for primary and foreign keys
    primary_key_type, foreign_key_type = primary_and_foreign_key_types

    create_table :active_storage_blobs, id: primary_key_type do |t|
      t.string   :key,          null: false
      t.string   :filename,     null: false
      t.string   :content_type
      t.text     :metadata
      t.string   :service_name, null: false
      t.bigint   :byte_size,    null: false
      t.string   :checksum

      if connection.supports_datetime_with_precision?
        t.datetime :created_at, precision: 6, null: false
      else
        t.datetime :created_at, null: false
      end

      t.index [ :key ], unique: true
    end

    create_table :active_storage_attachments, id: primary_key_type do |t|
      t.string     :name,     null: false
      t.references :record,   null: false, polymorphic: true, index: false, type: foreign_key_type
      t.references :blob,     null: false, type: foreign_key_type

      if connection.supports_datetime_with_precision?
        t.datetime :created_at, precision: 6, null: false
      else
        t.datetime :created_at, null: false
      end

      t.index [ :record_type, :record_id, :name, :blob_id ], name: :index_active_storage_attachments_uniqueness, unique: true
      t.foreign_key :active_storage_blobs, column: :blob_id
    end

    create_table :active_storage_variant_records, id: primary_key_type do |t|
      t.belongs_to :blob, null: false, index: false, type: foreign_key_type
      t.string :variation_digest, null: false

      t.index [ :blob_id, :variation_digest ], name: :index_active_storage_variant_records_uniqueness, unique: true
      t.foreign_key :active_storage_blobs, column: :blob_id
    end
  end

  private
    def primary_and_foreign_key_types
      config = Rails.configuration.generators
      setting = config.options[config.orm][:primary_key_type]
      primary_key_type = setting || :primary_key
      foreign_key_type = setting || :bigint
      [primary_key_type, foreign_key_type]
    end
end

class CreateRegions < ActiveRecord::Migration[7.1]
  def change
    create_table :regions do |t|
      t.string :name
      t.string :code

      t.timestamps
    end
  end
end

class CreateDistricts < ActiveRecord::Migration[7.1]
  def change
    create_table :districts do |t|
      t.string :name
      t.string :code
      t.references :region, null: false, foreign_key: true

      t.timestamps
    end
  end
end

class CreateFireDepartments < ActiveRecord::Migration[7.1]
  def change
    create_table :fire_departments do |t|
      t.string :name
      t.string :code
      t.references :district, null: false, foreign_key: true
      t.string :address

      t.timestamps
    end
  end
end


class CreateFireDepartmentMemberships < ActiveRecord::Migration[7.1]
  def change
    create_table :fire_department_memberships do |t|
      t.date :start_date
      t.references :fire_department, null: false, foreign_key: true
      t.references :account, null: false, foreign_key: true
      t.integer :role
      t.integer :status

      t.timestamps
    end
  end
end
class CreateAwards < ActiveRecord::Migration[7.1]
  def change
    create_table :awards do |t|
      t.string :name
      t.integer :award_kind
      t.integer :dependent_on_award_id
      t.integer :minimum_service_years
      t.integer :minimum_age_for_award

      t.timestamps
    end
  end
end
class AddMemberDetailsToAccounts < ActiveRecord::Migration[7.1]
  def change
    add_column :accounts, :first_name, :string
    add_column :accounts, :last_name, :string
    add_column :accounts, :birthdate, :date
    add_column :accounts, :address, :string
    add_column :accounts, :phone, :string
    add_column :accounts, :member_code, :string
    add_column :accounts, :role, :string
  end
end
class CreateJoinTableAccountsAwards < ActiveRecord::Migration[7.1]
  def change
    create_join_table :accounts, :awards do |t|
      # t.index [:account_id, :award_id]
      # t.index [:award_id, :account_id]
    end
  end
end


Modely:

class Account < ApplicationRecord
  include Rodauth::Model(RodauthMain)
  enum :status, unverified: 1, verified: 2, closed: 3

  has_many :fire_department_memberships, dependent: :destroy
  has_many :fire_departments, through: :fire_department_memberships
  has_and_belongs_to_many :awards, dependent: :destroy

  enum role: { nothing: 0, superadmin: 1}

  validates :first_name, presence: true, length: { maximum: 70 }
  validates :last_name, presence: true, length: { maximum: 70 }
  validates :birthdate, presence: true
  validates :address, length: { maximum: 255 }, allow_blank: true
  validates :phone, presence: true, uniqueness: true
  validates :member_code, presence: true, uniqueness: true
  validates :role, presence: true


  def full_name
    "#{first_name} #{last_name}"
  end

  def self.ransackable_attributes(auth_object = nil)
    ["address", "birthdate", "email", "first_name", "id", "last_name", "member_code" "phone", "role", "status"]
  end

end
class Award < ApplicationRecord
  belongs_to :account, optional: true
  belongs_to :dependent_on_award, class_name: 'Award', optional: true
  has_one_attached :image, dependent: :destroy
  has_and_belongs_to_many :accounts

  enum award_kind: { acknowledgement: 0, medal: 1, magnitude: 2 }

  validates :name, presence: true, length: { maximum: 100 }
  validates :award_kind, presence: true, inclusion: { in: award_kinds.keys }
  # validates :dependent_on_award_id, presence: true, allow_blank: true
  validates :minimum_service_years, presence: true, numericality: { greater_than_or_equal_to: 0, only_integer: true  }
  validates :minimum_age_for_award, presence: true, numericality: { greater_than_or_equal_to: 0, only_integer: true  }
end
class District < ApplicationRecord
  belongs_to :region
  has_many :fire_departments

  before_validation :upcase_code

  validates :name, presence: true, uniqueness: true, length: { maximum: 100 }
  validates :code, presence: true, uniqueness: true, length: { maximum: 10 }
  validates :region_id, presence: true, numericality: { greater_than_or_equal_to: 0, only_integer: true  }

  private

  def upcase_code
    self.code = code.upcase if code.present?
  end
end
class FireDepartment < ApplicationRecord
  belongs_to :district
  has_many :fire_department_memberships
  has_many :accounts, through: :fire_department_memberships

  before_validation :upcase_code

  validates :name, presence: true, uniqueness: true, length: { maximum: 100 }
  validates :code, presence: true, uniqueness: true, length: { maximum: 10 }
  validates :address, presence: true, length: { maximum: 255 }
  validates :district_id, presence: true, numericality: { greater_than_or_equal_to: 0, only_integer: true  }

  private

  def upcase_code
    self.code = code.upcase if code.present?
  end
end
class FireDepartmentMembership < ApplicationRecord
  belongs_to :fire_department
  belongs_to :account

  enum role: { member: 0, admin: 1 }
  enum status: { active: 0, archived: 1 }

  validates :start_date, presence: true
  validates :role, presence: true, inclusion: { in: roles.keys }
  validates :status, presence: true, inclusion: { in: statuses.keys }
  validates :fire_department_id, presence: true, numericality: { greater_than_or_equal_to: 0, only_integer: true  }
  validates :account_id, presence: true, numericality: { greater_than_or_equal_to: 0, only_integer: true  }

  validate :validate_active_account

  private

  def validate_active_account
    return unless account_id.present?

    existing_active_membership = FireDepartmentMembership.find_by(account_id: account_id, status: :active)
    if status == 'active' && existing_active_membership && existing_active_membership.id != id
      errors.add(:account_id, "can't have more than one active membership")
    end
  end
end
class Region < ApplicationRecord
  has_many :districts

  before_validation :upcase_code

  validates :name, presence: true, uniqueness: true, length: { maximum: 100 }
  validates :code, presence: true, uniqueness: true, length: { maximum: 10 }


  def self.ransackable_attributes(auth_object = nil)
    ["name", "code"]
  end

  private

  def upcase_code
    self.code = code.upcase if code.present?
  end
end


Kontrolery:
class Api::V1::FireDepartmentsController < ApplicationController
  before_action :authenticate #TODO: move token methon into one place
  before_action :set_fire_department, only: %i[ show ]

  # GET /fire_departments
  def index
    @q = FireDepartment.all.ransack(params[:q])
    @fire_departments = @q.result
    render json: { fire_departments: @fire_departments}
  end

  # GET /fire_departments/1
  def show
    render json: @fire_department
  end

  private

  def authenticate
    token = ENV["API_SECRET_TOKEN"]

    authenticate_or_request_with_http_token do |received_token, options|
      ActiveSupport::SecurityUtils.secure_compare(received_token, token)
    end
  end

    # Use callbacks to share common setup or constraints between actions.
    def set_fire_department
      @fire_department = FireDepartment.find(params[:id])
    end

    # Only allow a list of trusted parameters through.
    def fire_department_params
      params.require(:fire_department).permit(:name, :code, :district_id, :address)
    end
end

class Api::V1::MembersController < ApplicationController
  before_action :authenticate
  skip_before_action :verify_authenticity_token
  before_action :set_member, only: [:show, :update, :destroy]

  # GET /members
  def index
    @q = Account.select(:id, :status, :email, :first_name, :last_name, :birthdate, :address,
                        :phone, :member_code, :role).ransack(params[:q])
    @members = @q.result
    render json: { members: @members}
  end

  # GET /members/:id
  def show
    render json: @member
  end

  # POST /members
  def create
    ActiveRecord::Base.transaction do
      RodauthApp.rodauth.create_account(login: member_params[:email])
      account = Account.find_by(email: member_params[:email])
      if account.update(member_params.except(:email))
        render json: { message: "User created successfully. Verification email has been sent." }, status: :created
      else
        render json: { error: account.errors.full_messages }, status: :unprocessable_entity
        raise ActiveRecord::Rollback
      end
    end
  end

  # PUT /members/:id
  def update
      if @member.update(update_params)
        render json: { message: "User updated successfully." }, status: :ok
      else
        render json: { error: @member.errors.full_messages }, status: :unprocessable_entity
      end
  end

  # DELETE /members/:id
  def destroy
    if @member.destroy
      render json: { message: "Account successfully deleted." }, status: :ok
    else
      render json: { error: "Failed to delete the account." }, status: :unprocessable_entity
    end
  end

  private

  def authenticate
    token = ENV["API_SECRET_TOKEN"]

    authenticate_or_request_with_http_token do |received_token, options|
      ActiveSupport::SecurityUtils.secure_compare(received_token, token)
    end
  end

  def set_member
    @member = Account.where(id: params[:id]).select(:id, :status, :email, :first_name, :last_name, :birthdate,
                                                    :address, :phone, :member_code, :role).first
  end

  def member_params
    params.require(:member).permit(:email, :first_name, :last_name, :member_code, :role, :birthdate, :phone, :address)
  end

  def update_params
    params.require(:member).permit(:first_name, :last_name, :member_code, :role, :birthdate, :phone, :address)
  end
end
class ApplicationController < ActionController::Base
  private

  def current_account
    rodauth.rails_account
  end
  helper_method :current_account

  def authenticate
    rodauth.require_account
  end
end
class AwardsController < ApplicationController
  before_action :set_award, only: %i[ show edit update destroy ]

  # GET /awards or /awards.json
  def index
    @awards = Award.all
  end

  # GET /awards/1 or /awards/1.json
  def show
  end

  # GET /awards/new
  def new
    @award = Award.new
  end

  # GET /awards/1/edit
  def edit
  end

  # POST /awards or /awards.json
  def create
    @award = Award.new(award_params)

    respond_to do |format|
      if @award.save
        format.html { redirect_to award_url(@award), notice: "Award was successfully created." }
        format.json { render :show, status: :created, location: @award }
      else
        format.html { render :new, status: :unprocessable_entity }
        format.json { render json: @award.errors, status: :unprocessable_entity }
      end
    end
  end

  # PATCH/PUT /awards/1 or /awards/1.json
  def update
    respond_to do |format|
      if @award.update(award_params)
        format.html { redirect_to award_url(@award), notice: "Award was successfully updated." }
        format.json { render :show, status: :ok, location: @award }
      else
        format.html { render :edit, status: :unprocessable_entity }
        format.json { render json: @award.errors, status: :unprocessable_entity }
      end
    end
  end

  # DELETE /awards/1 or /awards/1.json
  def destroy
    @award.destroy!

    respond_to do |format|
      format.html { redirect_to awards_url, notice: "Award was successfully destroyed." }
      format.json { head :no_content }
    end
  end

  private
    # Use callbacks to share common setup or constraints between actions.
    def set_award
      @award = Award.find(params[:id])
    end

    # Only allow a list of trusted parameters through.
  def award_params
    params.require(:award).permit(:name, :award_kind, :minimum_service_years, :minimum_age_for_award, :image, :dependent_on_award_id)
  end

end
class DistrictsController < ApplicationController
  before_action :set_district, only: %i[ show edit update destroy ]

  # GET /districts or /districts.json
  def index
    @districts = District.all
  end

  # GET /districts/1 or /districts/1.json
  def show
  end

  # GET /districts/new
  def new
    @district = District.new
  end

  # GET /districts/1/edit
  def edit
  end

  # POST /districts or /districts.json
  def create
    @district = District.new(district_params)

    respond_to do |format|
      if @district.save
        format.html { redirect_to district_url(@district), notice: "District was successfully created." }
        format.json { render :show, status: :created, location: @district }
      else
        format.html { render :new, status: :unprocessable_entity }
        format.json { render json: @district.errors, status: :unprocessable_entity }
      end
    end
  end

  # PATCH/PUT /districts/1 or /districts/1.json
  def update
    respond_to do |format|
      if @district.update(district_params)
        format.html { redirect_to district_url(@district), notice: "District was successfully updated." }
        format.json { render :show, status: :ok, location: @district }
      else
        format.html { render :edit, status: :unprocessable_entity }
        format.json { render json: @district.errors, status: :unprocessable_entity }
      end
    end
  end

  # DELETE /districts/1 or /districts/1.json
  def destroy
    @district.destroy!

    respond_to do |format|
      format.html { redirect_to districts_url, notice: "District was successfully destroyed." }
      format.json { head :no_content }
    end
  end

  private
    # Use callbacks to share common setup or constraints between actions.
    def set_district
      @district = District.find(params[:id])
    end

    # Only allow a list of trusted parameters through.
    def district_params
      params.require(:district).permit(:name, :code, :region_id)
    end
end
class FireDepartmentMembershipsController < ApplicationController
  before_action :set_fire_department_membership, only: %i[ show edit update destroy ]

  # GET /fire_department_memberships or /fire_department_memberships.json
  def index
    @fire_department_memberships = FireDepartmentMembership.all
  end

  # GET /fire_department_memberships/1 or /fire_department_memberships/1.json
  def show
  end

  # GET /fire_department_memberships/new
  def new
    @fire_department_membership = FireDepartmentMembership.new
  end

  # GET /fire_department_memberships/1/edit
  def edit
  end

  # POST /fire_department_memberships or /fire_department_memberships.json
  def create
    @fire_department_membership = FireDepartmentMembership.new(fire_department_membership_params)

    respond_to do |format|
      if @fire_department_membership.save
        format.html { redirect_to fire_department_membership_url(@fire_department_membership), notice: "Fire department membership was successfully created." }
        format.json { render :show, status: :created, location: @fire_department_membership }
      else
        format.html { render :new, status: :unprocessable_entity }
        format.json { render json: @fire_department_membership.errors, status: :unprocessable_entity }
      end
    end
  end

  # PATCH/PUT /fire_department_memberships/1 or /fire_department_memberships/1.json
  def update
    respond_to do |format|
      if @fire_department_membership.update(fire_department_membership_params)
        format.html { redirect_to fire_department_membership_url(@fire_department_membership), notice: "Fire department membership was successfully updated." }
        format.json { render :show, status: :ok, location: @fire_department_membership }
      else
        format.html { render :edit, status: :unprocessable_entity }
        format.json { render json: @fire_department_membership.errors, status: :unprocessable_entity }
      end
    end
  end

  # DELETE /fire_department_memberships/1 or /fire_department_memberships/1.json
  def destroy
    @fire_department_membership.destroy!

    respond_to do |format|
      format.html { redirect_to fire_department_memberships_url, notice: "Fire department membership was successfully destroyed." }
      format.json { head :no_content }
    end
  end

  private
    # Use callbacks to share common setup or constraints between actions.
    def set_fire_department_membership
      @fire_department_membership = FireDepartmentMembership.find(params[:id])
    end

    # Only allow a list of trusted parameters through.
    def fire_department_membership_params
      params.require(:fire_department_membership).permit(:start_date, :fire_department_id, :account_id, :role, :status)
    end
end
class FireDepartmentsController < ApplicationController
  before_action :set_fire_department, only: %i[ show edit update destroy ]

  # GET /fire_departments or /fire_departments.json
  def index
    @fire_departments = FireDepartment.all
  end

  # GET /fire_departments/1 or /fire_departments/1.json
  def show
  end

  # GET /fire_departments/new
  def new
    @fire_department = FireDepartment.new
  end

  # GET /fire_departments/1/edit
  def edit
  end

  # POST /fire_departments or /fire_departments.json
  def create
    @fire_department = FireDepartment.new(fire_department_params)

    respond_to do |format|
      if @fire_department.save
        format.html { redirect_to fire_department_url(@fire_department), notice: "Fire department was successfully created." }
        format.json { render :show, status: :created, location: @fire_department }
      else
        format.html { render :new, status: :unprocessable_entity }
        format.json { render json: @fire_department.errors, status: :unprocessable_entity }
      end
    end
  end

  # PATCH/PUT /fire_departments/1 or /fire_departments/1.json
  def update
    respond_to do |format|
      if @fire_department.update(fire_department_params)
        format.html { redirect_to fire_department_url(@fire_department), notice: "Fire department was successfully updated." }
        format.json { render :show, status: :ok, location: @fire_department }
      else
        format.html { render :edit, status: :unprocessable_entity }
        format.json { render json: @fire_department.errors, status: :unprocessable_entity }
      end
    end
  end

  # DELETE /fire_departments/1 or /fire_departments/1.json
  def destroy
    @fire_department.destroy!

    respond_to do |format|
      format.html { redirect_to fire_departments_url, notice: "Fire department was successfully destroyed." }
      format.json { head :no_content }
    end
  end

  private
    # Use callbacks to share common setup or constraints between actions.
    def set_fire_department
      @fire_department = FireDepartment.find(params[:id])
    end

    # Only allow a list of trusted parameters through.
    def fire_department_params
      params.require(:fire_department).permit(:name, :code, :district_id, :address)
    end
end
class MembersController < ApplicationController
  before_action :set_member, only: [:show]

  # GET /members
  def index
    @members = Account.all
  end

  # GET /members/:id
  def show
  end

  # POST /members
  # def create
  #   ActiveRecord::Base.transaction do
  #     RodauthApp.rodauth.create_account(login: member_params[:email])
  #     account = Account.find_by(email: member_params[:email])
  #     if account.update(member_params.except(:email))
  #       render json: { message: "User created successfully. Verification email has been sent." }, status: :created
  #     else
  #       render json: { error: account.errors.full_messages }, status: :unprocessable_entity
  #       raise ActiveRecord::Rollback
  #     end
  #   end
  # end

  private

  def set_member
    @member = Account.find(params[:id])
  end

  def member_params
    params.require(:member).permit(:email, :first_name, :last_name, :member_code, :role, :birthdate, :phone, :address)
  end
end
class RegionsController < ApplicationController
  before_action :set_region, only: %i[ show edit update destroy ]

  # GET /regions or /regions.json
  def index
    @q = Region.ransack(params[:q])
    @regions = @q.result(distinct: true).page(params[:page])
  end

  # GET /regions/1 or /regions/1.json
  def show
  end

  # GET /regions/new
  def new
    @region = Region.new
  end

  # GET /regions/1/edit
  def edit
  end

  # POST /regions or /regions.json
  def create
    @region = Region.new(region_params)

    respond_to do |format|
      if @region.save
        format.html { redirect_to region_url(@region), notice: "Region was successfully created." }
        format.json { render :show, status: :created, location: @region }
      else
        format.html { render :new, status: :unprocessable_entity }
        format.json { render json: @region.errors, status: :unprocessable_entity }
      end
    end
  end

  # PATCH/PUT /regions/1 or /regions/1.json
  def update
    respond_to do |format|
      if @region.update(region_params)
        format.html { redirect_to region_url(@region), notice: "Region was successfully updated." }
        format.json { render :show, status: :ok, location: @region }
      else
        format.html { render :edit, status: :unprocessable_entity }
        format.json { render json: @region.errors, status: :unprocessable_entity }
      end
    end
  end

  # DELETE /regions/1 or /regions/1.json
  def destroy
    @region.destroy!

    respond_to do |format|
      format.html { redirect_to regions_url, notice: "Region was successfully destroyed." }
      format.json { head :no_content }
    end
  end

  private
    # Use callbacks to share common setup or constraints between actions.
    def set_region
      @region = Region.find(params[:id])
    end

    # Only allow a list of trusted parameters through.
    def region_params
      params.require(:region).permit(:name, :code)
    end
end

gemfile:

source "https://rubygems.org"

ruby "3.3.0"

# Bundle edge Rails instead: gem "rails", github: "rails/rails", branch: "main"
gem "rails", "~> 7.1.3", ">= 7.1.3.2"

# The original asset pipeline for Rails [https://github.com/rails/sprockets-rails]
gem "sprockets-rails"

# Use sqlite3 as the database for Active Record
gem "sqlite3", "~> 1.4"

# Use the Puma web server [https://github.com/puma/puma]
gem "puma", ">= 5.0"

# Use JavaScript with ESM import maps [https://github.com/rails/importmap-rails]
gem "importmap-rails"

# Hotwire's SPA-like page accelerator [https://turbo.hotwired.dev]
gem "turbo-rails"

# Hotwire's modest JavaScript framework [https://stimulus.hotwired.dev]
gem "stimulus-rails"

# Use Tailwind CSS [https://github.com/rails/tailwindcss-rails]
gem "tailwindcss-rails"

# Build JSON APIs with ease [https://github.com/rails/jbuilder]
gem "jbuilder"

gem 'simple_form', '~> 5.3'
gem 'simple_form-tailwind', '~> 0.1.1'
gem 'rails-patterns', '~> 0.11.0'
# gem 'jsonapi-resources'
gem 'solid_queue', '~> 0.3.0'
gem 'panoptic', '~> 0.5.0'
gem 'ransack', "~> 4.1.1"
gem 'kaminari', "~> 1.2.2"


gem "rodauth-rails", "~> 1.14"
gem 'argon2', "~> 2.3.0"
gem 'rack-cors', '~> 2.0', '>= 2.0.2'


# Use Redis adapter to run Action Cable in production
# gem "redis", ">= 4.0.1"

# Use Kredis to get higher-level data types in Redis [https://github.com/rails/kredis]
# gem "kredis"

# Use Active Model has_secure_password [https://guides.rubyonrails.org/active_model_basics.html#securepassword]
# gem "bcrypt", "~> 3.1.7"

# Windows does not include zoneinfo files, so bundle the tzinfo-data gem
gem "tzinfo-data", platforms: %i[ windows jruby ]

# Reduces boot times through caching; required in config/boot.rb
gem "bootsnap", require: false

# Use Active Storage variants [https://guides.rubyonrails.org/active_storage_overview.html#transforming-images]
gem "image_processing", "~> 1.2"

group :development, :test do
  # See https://guides.rubyonrails.org/debugging_rails_applications.html#debugging-with-the-debug-gem
  gem "debug", platforms: %i[ mri windows ]

  gem 'foreman', '~> 0.87.2'

  gem 'rspec-rails', '~> 6.1', '>= 6.1.2'
  gem 'rails-controller-testing', '~> 1.0', '>= 1.0.5'
  gem 'shoulda-matchers', '~> 6.2'
  gem 'factory_bot_rails', '~> 6.4', '>= 6.4.3'
  gem 'faker', '~> 3.3'
  gem 'rswag', '~> 2.13.0'
end

group :development do
  # Use console on exceptions pages [https://github.com/rails/web-console]
  gem "web-console"

  # Add speed badges [https://github.com/MiniProfiler/rack-mini-profiler]
  # gem "rack-mini-profiler"

  # Speed up commands on slow machines / big apps [https://github.com/rails/spring]
  # gem "spring"
end

group :test do
  # Use system testing [https://guides.rubyonrails.org/testing.html#system-testing]
  gem 'database_cleaner'
  gem "capybara"
  gem "selenium-webdriver"
end


